<!DOCTYPE html>
<html><!-- InstanceBegin template="/Templates/as2-doc.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta charset="utf-8">
<link href="as2-doc.css" rel="stylesheet" type="text/css">
<script src="jquery.min.js" type="text/javascript"></script>
<script src="as2-doc.js" type="text/javascript"></script>
<!-- InstanceBeginEditable name="head" -->
<title>Lua Scripts</title>
<!-- InstanceEndEditable -->
</head>
<body>
<h1 id="about">About</h1>
<address>Author: <a href="index.html#contact">DeathByNukes</a></address>
<p>This is a part of my <a href="index.html">Audiosurf 2 scripting documentation</a>.</p>
<!-- InstanceBeginEditable name="pre-content" --><!-- InstanceEndEditable -->
<h1 id="contents">Contents</h1>
<script type="text/javascript">writeNavigation();</script>
<!-- InstanceBeginEditable name="content" -->
<h1 id="header">Header</h1>
<p>These scripts run first inside Skin and Mod Lua environments:</p>
<h2 id="header-sandbox">Sandbox</h2>
<p>This block can be disabled by the command line flag <code>+disablemodsecuritysandbox</code>. That flag seems to have been neglected when the security system was upgraded, as this is the only part of the game that checks it.</p>
<pre class=LuaCode><code>
assert(nil == package)
assert(nil == io)
assert(nil == require)
assert(nil == module)

assert(nil == os.execute)
assert(nil == os.exit)
assert(nil == os.getenv)
assert(nil == os.remove)
assert(nil == os.rename)
assert(nil == os.setlocale)
assert(nil == os.tmpname)

assert(nil == luanet)
assert(nil == load_assembly)

--dofile = nil
--loadfile = nil</code></pre>
<h2 id="header-lib">Library</h2>
<p></p>
<pre class=LuaCode><code>


-- each DoString is a different Lua scope, no need for a giant do...end
local auto, assign

function auto(tab, key)
    return setmetatable({}, {
            __index = auto,
            __newindex = assign,
            parent = tab,
            key = key
    })
end

local meta = {__index = auto}

-- The if statement below prevents the table from being
-- created if the value assigned is nil. This is, I think,
-- technically correct but it might be desirable to use
-- assignment to nil to force a table into existence.

function assign(tab, key, val)
    -- if val ~= nil then
    local oldmt = getmetatable(tab)
    oldmt.parent[oldmt.key] = tab
    setmetatable(tab, meta)
    tab[key] = val
    -- end
end

function AutomagicTable()
    return setmetatable({}, meta)
end

function fif(test, if_true, if_false)
    if test then return if_true else return if_false end
end

function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end
        setmetatable(copy, deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end


-- start coroutine helpers
-- This table is indexed by coroutine and simply contains the time at which the coroutine
-- should be woken up.
local WAITING_ON_TIME = WAITING_ON_TIME or {}

-- Keep track of how long the game has been running.
local CURRENT_TIME = CURRENT_TIME or 0

function waitSeconds(seconds)
    -- Grab a reference to the current running coroutine.
    local co = coroutine.running()

    -- If co is nil, that means we're on the main process, which isn't a coroutine and can't yield
    assert(co ~= nil, 'The main thread cannot wait!')

    -- Store the coroutine and its wakeup time in the WAITING_ON_TIME table
    local wakeupTime = CURRENT_TIME + seconds
    WAITING_ON_TIME[co] = wakeupTime

    -- And suspend the process
    return coroutine.yield(co)
end

function wakeUpWaitingThreads(deltaTime)
    -- This function should be called once per game logic update with the amount of time
    -- that has passed since it was last called
    CURRENT_TIME = CURRENT_TIME + deltaTime

    -- First, grab a list of the threads that need to be woken up. They'll need to be removed
    -- from the WAITING_ON_TIME table which we don't want to try and do while we're iterating
    -- through that table, hence the list.
    local threadsToWake = {}
    for co, wakeupTime in pairs(WAITING_ON_TIME) do
        if wakeupTime < CURRENT_TIME then
            table.insert(threadsToWake, co)
        end
    end

    -- Now wake them all up.
    for _, co in ipairs(threadsToWake) do
        WAITING_ON_TIME[co] = nil -- Setting a field to nil removes it from the table
        coroutine.resume(co)
    end
end

function runProcess(func)
    -- This function is just a quick wrapper to start a coroutine.
    local co = coroutine.create(func)
    return coroutine.resume(co)
end

local WAITING_ON_SIGNAL = WAITING_ON_SIGNAL or {}

function waitSignal(signalName)
    -- Same check as in waitSeconds; the main thread cannot wait
    local co = coroutine.running()
    assert(co ~= nil, 'The main thread cannot wait!')

    if WAITING_ON_SIGNAL[signalStr] == nil then
        -- If there wasn't already a list for this signal, start a new one.
        WAITING_ON_SIGNAL[signalName] = { co }
    else
        table.insert(WAITING_ON_SIGNAL[signalName], co)
    end

    return coroutine.yield()
end

function signal(signalName)
    local threads = WAITING_ON_SIGNAL[signalName]
    if threads == nil then return end

    WAITING_ON_SIGNAL[signalName] = nil
    for _, co in ipairs(threads) do
        coroutine.resume(co)
    end
end
--end coroutine helpers
</code></pre>
<p>AutomagicTable matches the code found here: <a href="http://lua-users.org/wiki/AutomagicTables">http://lua-users.org/wiki/AutomagicTables</a></p>
<h2 id="header-seed">Random Seed</h2>
<p>A Lua script line is generated that calls <code><a href="https://www.lua.org/manual/5.1/manual.html#pdf-math.randomseed" class=func>math.randomseed</a>(n)</code> where <code>n</code> is the total length of the song, in seconds, with no decimal. (This is appropriate because <code><a href="https://www.lua.org/manual/5.1/manual.html#pdf-math.randomseed" class=func>math.randomseed</a></code> discards the fraction anyways.)</p>
<!-- InstanceEndEditable -->
</body>
<!-- InstanceEnd --></html>